const bootstrap = require('../shared/bootstrap');const { createReqRes, finalizeResponse, runPipeline, sendError } = require('../shared/adapter');const authController = require('../backend/src/controllers/authController');const { authenticate } = require('../backend/src/middleware/auth');const withCors = (req, res) => {  const origin = req.headers?.origin;  if (origin) {    res.setHeader('Access-Control-Allow-Origin', origin);    res.setHeader('Vary', 'Origin');  }  res.setHeader('Access-Control-Allow-Credentials', 'true');  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PUT,PATCH,DELETE,OPTIONS');};module.exports = async function (context, req) {  const { expressReq, res } = createReqRes(context, req);  withCors(expressReq, res);  if (String(expressReq.method || '').toUpperCase() === 'OPTIONS') {    res.status(204).send('');    return finalizeResponse(context, res);  }  try {    await bootstrap();    const pathRaw = String(context.bindingData?.path || '').replace(/^\/+/, '');    const segments = pathRaw.split('/').filter(Boolean);    const method = String(expressReq.method || '').toUpperCase();    const action = segments[0] || '';    let handlers = null;    // POST /api/auth/signup    if (method === 'POST' && action === 'signup') {      handlers = [authController.signup];    }    // POST /api/auth/login    if (method === 'POST' && action === 'login') {      handlers = [authController.login];    }    // POST /api/auth/logout    if (method === 'POST' && action === 'logout') {      handlers = [authController.logout];    }    // GET /api/auth/me    if (method === 'GET' && action === 'me') {      handlers = [authenticate, authController.getProfile];    }    // POST /api/auth/reset-account    if (method === 'POST' && (action === 'reset-account' || action === 'reset')) {      handlers = [authController.resetAccount];    }    // GET /api/auth/roles    if (method === 'GET' && action === 'roles') {      handlers = [authenticate, authController.getRoleAssignments];    }    // POST /api/auth/roles    if (method === 'POST' && action === 'roles') {      handlers = [authenticate, authController.assignRole];    }    // GET /api/auth/executors    if (method === 'GET' && action === 'executors') {      handlers = [authenticate, authController.listExecutors];    }    // POST /api/auth/executors    if (method === 'POST' && action === 'executors') {      handlers = [authenticate, authController.createExecutor];    }    // PUT /api/auth/executors/:username    if (method === 'PUT' && action === 'executors' && segments[1]) {      expressReq.params.username = segments[1];      handlers = [authenticate, authController.updateExecutor];    }    // POST /api/auth/executors/:username/reset-password    if (method === 'POST' && action === 'executors' && segments[1] && segments[2] === 'reset-password') {      expressReq.params.username = segments[1];      handlers = [authenticate, authController.resetExecutorPassword];    }    // DELETE /api/auth/executors/:username    if (method === 'DELETE' && action === 'executors' && segments[1]) {      expressReq.params.username = segments[1];      handlers = [authenticate, authController.deleteExecutor];    }    if (!handlers) {      res.status(404).json({ error: 'Not found' });      return finalizeResponse(context, res);    }    await runPipeline(expressReq, res, handlers);  } catch (err) {    context.log.error('[auth]', err?.message || err);    sendError(res, err);  }  return finalizeResponse(context, res);};